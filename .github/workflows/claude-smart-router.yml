name: Claude Smart Router

# Unified concurrency control to prevent workflow conflicts
concurrency:
  group: claude-router-${{ github.event.issue.number || github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

on:
  issue_comment:
    types: [created]
  issues:
    types: [opened, labeled]
  pull_request_review_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

jobs:
  # Context Analysis - Determines routing for all subsequent jobs
  analyze-context:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && contains(github.event.issue.body, '@claude')) ||
      (github.event_name == 'issues' && contains(github.event.issue.title, '@claude')) ||
      (github.event_name == 'issues' && github.event.action == 'labeled' && contains(join(github.event.issue.labels.*.name, ' '), 'needs-clarification')) ||
      (github.event_name == 'issues' && github.event.action == 'labeled' && contains(join(github.event.issue.labels.*.name, ' '), 'spec-in-progress')) ||
      (github.event_name == 'issues' && github.event.action == 'labeled' && contains(join(github.event.issue.labels.*.name, ' '), 'ready-for-implementation'))
    
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      issues: read
      pull-requests: read
      id-token: write
    
    outputs:
      intent: ${{ steps.analyze.outputs.intent }}
      issue_number: ${{ steps.analyze.outputs.issue_number }}
      has_claude_mention: ${{ steps.analyze.outputs.has_claude_mention }}
      current_labels: ${{ steps.analyze.outputs.current_labels }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Analyze context and determine intent
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            
            // Extract issue number
            const issueNumber = context.issue?.number || context.payload.pull_request?.number;
            core.setOutput('issue_number', issueNumber);
            
            // Check for @claude mention
            let hasClaude = false;
            let content = '';
            
            if (context.eventName === 'issue_comment') {
              content = context.payload.comment.body;
              hasClaude = content.includes('@claude');
            } else if (context.eventName === 'issues') {
              content = context.payload.issue.body + ' ' + context.payload.issue.title;
              hasClaude = content.includes('@claude');
            } else if (context.eventName === 'pull_request_review_comment') {
              content = context.payload.comment.body;
              hasClaude = content.includes('@claude');
            } else if (context.eventName === 'pull_request_review') {
              content = context.payload.review.body;
              hasClaude = content.includes('@claude');
            }
            
            core.setOutput('has_claude_mention', hasClaude);
            console.log(`Claude mention detected: ${hasClaude}`);
            
            // Get current labels for issues
            let currentLabels = [];
            let intent = 'general';
            
            if (issueNumber && context.eventName !== 'pull_request_review' && context.eventName !== 'pull_request_review_comment') {
              try {
                const { data: issue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                
                currentLabels = issue.labels.map(label => label.name);
                core.setOutput('current_labels', JSON.stringify(currentLabels));
                console.log(`Current labels: ${JSON.stringify(currentLabels)}`);
                
                // Determine intent based on labels and content
                if (currentLabels.includes('needs-clarification')) {
                  intent = 'clarification';
                } else if (currentLabels.includes('spec-in-progress') || currentLabels.includes('spec-ready')) {
                  intent = 'specification';
                } else if (currentLabels.includes('ready-for-implementation')) {
                  intent = 'implementation';
                } else if (currentLabels.includes('enhancement') || currentLabels.includes('bug')) {
                  // New issue that needs clarification
                  intent = 'clarification';
                } else {
                  // General AI assistance
                  intent = 'general';
                }
                
                console.log(`Determined intent: ${intent}`);
                
              } catch (error) {
                console.log(`Error fetching issue: ${error.message}`);
                intent = 'general';
              }
            } else {
              // Pull request context - general assistance
              intent = 'general';
            }
            
            core.setOutput('intent', intent);
            console.log(`Final intent: ${intent}, Issue: ${issueNumber}`);

  # Requirement Clarification Job
  clarification:
    needs: analyze-context
    if: needs.analyze-context.outputs.intent == 'clarification' && needs.analyze-context.outputs.has_claude_mention == 'true'
    
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      issues: write
      pull-requests: read
      id-token: write
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Requirement Clarification
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          
          custom_instructions: |
            You are helping clarify requirements for IlliniHunt V2, a Product Hunt-style platform for UIUC students.
            
            Your role in this workflow:
            1. ANALYZE the issue thoroughly to understand what the user wants
            2. ASK specific clarifying questions to fill gaps in the requirements
            3. PROBE for edge cases, user flows, and technical constraints
            4. REQUEST mockups, examples, or references if needed
            5. When requirements are clear, tell the user you'll create a specification
            
            Key areas to clarify:
            - Exact user flows and interactions
            - Edge cases and error handling
            - Mobile vs desktop behavior differences
            - Integration with existing features
            - Performance and accessibility requirements
            - Success criteria and acceptance tests
            
            Architecture context:
            - Frontend: React + TypeScript + Tailwind CSS + shadcn/ui
            - Backend: Supabase (PostgreSQL + Auth + Real-time)
            - Deployment: Vercel
            - Authentication: Google OAuth restricted to @illinois.edu
            
            Communication style:
            - Be friendly and encouraging for non-technical users
            - Ask focused questions to avoid overwhelming
            - Provide examples to help users understand what you need
            - Use emojis and clear formatting for readability
            
            When requirements are clear, respond with "I have enough information to create a detailed specification. I'll now move to the specification phase." and include the phrase "spec-in-progress" to trigger the next workflow phase.

  # Specification Generation Job
  specification:
    needs: analyze-context
    if: needs.analyze-context.outputs.intent == 'specification' && needs.analyze-context.outputs.has_claude_mention == 'true'
    
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      issues: write
      pull-requests: read
      id-token: write
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Specification Generation
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          
          custom_instructions: |
            You are creating detailed technical specifications for IlliniHunt V2 features.
            
            Your role in this workflow:
            1. ANALYZE the clarified requirements from the issue conversation
            2. CREATE a comprehensive technical specification using the SPEC_TEMPLATE format
            3. INCLUDE all necessary technical details for implementation
            4. REQUEST user approval with a clear approval checklist
            5. When approved, indicate you're ready for implementation phase
            
            Use the specification template structure from .github/SPEC_TEMPLATE.md and include:
            - Feature overview and success criteria
            - Detailed requirements analysis
            - Technical architecture (frontend/backend)
            - User experience design
            - Testing strategy
            - Implementation plan with timeline
            - User approval checklist
            
            Architecture context:
            - Frontend: React 18 + TypeScript + Vite + Tailwind CSS + shadcn/ui
            - State: React Context + React Hook Form + Zod validation
            - Backend: Supabase (PostgreSQL + Auth + Real-time + Storage)
            - Deployment: Vercel with automatic deployments
            - Authentication: Google OAuth restricted to @illinois.edu domains
            - Design System: UIUC brand colors (uiuc-orange: #FF6B35, uiuc-blue: #13294B)
            
            Communication style:
            - Be thorough but accessible to non-technical users
            - Use visual formatting (headers, lists, checkboxes) for clarity
            - Explain technical decisions in user-friendly terms
            - Provide mockup descriptions where helpful
            
            When you complete the specification, include the phrase "spec-ready" to update labels appropriately.

  # Implementation Job
  implementation:
    needs: analyze-context
    if: needs.analyze-context.outputs.intent == 'implementation' && needs.analyze-context.outputs.has_claude_mention == 'true'
    
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Claude Implementation
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          
          allowed_tools: |
            Bash(npm install)
            Bash(npm run build)
            Bash(npm run lint)
            Bash(npm run type-check)
            Bash(npm test --passWithNoTests)
          
          custom_instructions: |
            You are implementing features for IlliniHunt V2 based on approved specifications.
            
            Your role in this workflow:
            1. CREATE a feature branch from main for this implementation
            2. IMPLEMENT the feature following the approved specification exactly
            3. ENSURE code quality with proper TypeScript types and error handling
            4. RUN all quality checks (build, lint, type-check)
            5. CREATE a comprehensive pull request with testing instructions
            6. UPDATE issue labels to indicate PR is ready for review
            
            Implementation Guidelines:
            
            ### Branch Management
            - Create branch with format: `feature/issue-{issue_number}-{feature-name}`
            - Base branch should always be `main`
            - Keep commits focused and atomic
            
            ### Code Quality Standards
            - Use TypeScript strict mode - no `any` types
            - Follow existing code patterns and architecture
            - Use existing components from shadcn/ui library
            - Maintain consistent styling with Tailwind CSS
            - Follow UIUC brand colors (uiuc-orange: #FF6B35, uiuc-blue: #13294B)
            - Add proper error handling and loading states
            - Ensure mobile-responsive design
            
            ### Frontend Implementation
            - React functional components with hooks
            - TypeScript interfaces for all data structures
            - React Hook Form + Zod for form validation
            - Proper state management with React Context when needed
            - Accessibility: ARIA labels, keyboard navigation
            - Performance: lazy loading, optimized re-renders
            
            ### Backend Integration
            - Use existing database service layer in `src/lib/database.ts`
            - Follow Supabase patterns for data fetching
            - Implement proper Row Level Security (RLS) policies
            - Add real-time subscriptions where specified
            - Handle authentication with existing auth context
            
            ### Testing & Validation
            - Run `npm run build` to ensure TypeScript compilation
            - Run `npm run lint` to check code style
            - Run `npm run type-check` for type validation
            - Test basic functionality manually if possible
            - Ensure no console errors in development
            
            Current Project Context:
            - Frontend: React 18 + TypeScript + Vite + Tailwind CSS + shadcn/ui
            - Backend: Supabase (PostgreSQL + Auth + Real-time)
            - Deployment: Vercel
            - Auth: Google OAuth with @illinois.edu restriction
            - Design: UIUC brand colors and responsive design
            - Code Style: Functional components, hooks, strict TypeScript
            
            When implementation is complete, include the phrase "claude-pr-ready" to update labels appropriately.

  # General AI Assistance Job
  general-help:
    needs: analyze-context
    if: needs.analyze-context.outputs.intent == 'general' && needs.analyze-context.outputs.has_claude_mention == 'true'
    
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude General Assistance
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

          allowed_tools: |
            Bash(npm install)
            Bash(npm run build)
            Bash(npm run lint)
            Bash(npm run type-check)
            Bash(npm test --passWithNoTests)
          
          custom_instructions: |
            You are Claude, an AI assistant helping with IlliniHunt V2 development - a Product Hunt-style platform for UIUC students.
            
            ## Project Context
            - **Frontend**: React 18 + TypeScript + Vite + Tailwind CSS + shadcn/ui components
            - **Backend**: Supabase (PostgreSQL + Auth + Real-time subscriptions)
            - **Authentication**: Google OAuth restricted to @illinois.edu emails
            - **Deployment**: Vercel with automatic deployments
            - **Design System**: UIUC brand colors (uiuc-orange: #FF6B35, uiuc-blue: #13294B)
            
            ## Code Quality Standards
            - **TypeScript**: Strict mode enabled, avoid `any` types
            - **React**: Functional components with hooks, proper state management
            - **Styling**: Tailwind CSS with existing design system, mobile-first responsive
            - **Testing**: Add tests for new functionality when applicable
            - **Performance**: Optimize for mobile devices, lazy loading where appropriate
            - **Accessibility**: ARIA labels, keyboard navigation, semantic HTML
            
            ## Communication Style
            - Be friendly and encouraging, especially with student contributors
            - Explain technical decisions clearly for non-technical users
            - Use emojis and clear formatting for readability
            - Provide specific, actionable guidance
            - Ask clarifying questions when requirements are unclear
            
            ## Academic Context
            - This is a learning platform for UIUC students
            - Contributions often connect to coursework (CS 225, CS 411, CS 465, BADM 350, etc.)
            - Emphasize learning opportunities and best practices
            - Encourage collaboration between students of different experience levels
            
            Provide helpful, educational responses that guide students through their development challenges while maintaining code quality standards.

  # Label Management Job - Handles label updates based on workflow phases
  manage-labels:
    needs: [analyze-context, clarification, specification, implementation, general-help]
    if: always() && needs.analyze-context.result == 'success'
    
    runs-on: ubuntu-latest
    permissions:
      issues: write
      
    steps:
      - name: Update issue labels based on workflow outcomes
        if: needs.analyze-context.outputs.issue_number
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ needs.analyze-context.outputs.issue_number }};
            const intent = '${{ needs.analyze-context.outputs.intent }}';
            
            if (!issueNumber) {
              console.log('No issue number found, skipping label management');
              return;
            }
            
            // Helper function to safely remove labels
            async function removeLabel(labelName) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  name: labelName
                });
                console.log(`Removed label: ${labelName}`);
              } catch (error) {
                console.log(`Label ${labelName} may not exist: ${error.message}`);
              }
            }
            
            // Helper function to add labels
            async function addLabel(labelName) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: [labelName]
                });
                console.log(`Added label: ${labelName}`);
              } catch (error) {
                console.log(`Error adding label ${labelName}: ${error.message}`);
              }
            }
            
            // Check job outcomes and update labels accordingly
            const clarificationResult = '${{ needs.clarification.result }}';
            const specificationResult = '${{ needs.specification.result }}';
            const implementationResult = '${{ needs.implementation.result }}';
            
            console.log(`Job results - Clarification: ${clarificationResult}, Specification: ${specificationResult}, Implementation: ${implementationResult}`);
            
            if (clarificationResult === 'success') {
              // Clarification completed - check if moving to spec phase
              // This would be determined by the clarification job's output
              console.log('Clarification job completed successfully');
            }
            
            if (specificationResult === 'success') {
              // Specification completed - labels will be managed by the specification job
              console.log('Specification job completed successfully');
            }
            
            if (implementationResult === 'success') {
              // Implementation completed - labels will be managed by the implementation job
              console.log('Implementation job completed successfully');
            }